This code maintains a singly linked list of map elements that have been added
to the document. An object should never be added to this list twice, as this
will cause a loop in the list (a map element pointing to itself as the next in
the list). However, the event-within-an-event can be used to first cause two
consecutive calls to remove the same element from this list followed by two
calls to add the same element to the list. This results in the following
sequence of events:

* The first call to remove the element will remove it from the list.
* The second call to remove the element will do nothing.
* The first call to add the element will add it to the list.
* The second call to add the element will try to add it to the list again,
  causing the list to contain a loop. This list is now corrupt.

At this point, an attacker can remove the `CMapElement`, causing the code to
try to remove it from the list and free it. However, because of the loop in the
list, the above code will not actually remove it from the list. After this,
the pointer in the list points to freed memory.

Exploit
-------
I focused on the `CMapElement::Notify` code and was able to reuse the freed
memory originally used for the `CMapElement` with another object of similar
size (eg. a `CParamElement`, which may be extra useful as it will store a
pointer to its parent `CObjectElement` at offset 38). However, I could not
think of a way to use the `CMapElement::Notify` code to do anything useful at
that point. I could also not immediately find any other code that uses this
linked list, which is a bit odd: why would MSIE keep a linked list and not use
it? I suspect there must be other code that uses it, and that this code may
allow exploitation of this vulnerability.

Aside from the use-after-free bug that exists for `CMapElement` objects above,
there may be many other issues for other types of objects, as there are many
different `C<ElenentName>Element::Notify` implementations for the various
elements. It is assumes that none of these were designed to be [reentrant][].
Unfortunately, I did not have time to exhaustively reverse engineer their code
to look for other code paths that might be exploitable. As a result I am unable
to prove exploitability beyond reasonable doubt.

[reentrant]: https://en.wikipedia.org/wiki/Reentrancy_(computing)

Time-line
---------
* *September 2014*: This vulnerability was found through fuzzing.
* *September 2014*: This vulnerability was submitted to [ZDI][].
* *September 2014*: This vulnerability was acquired by ZDI.
* *February 2015*: Microsoft address this issue in [MS15-009][].
* *November 2016*: Details of this issue are released.

[ZDI]: http://www.zerodayinitiative.com/
[MS15-009]: https://technet.microsoft.com/library/security/MS15-009
